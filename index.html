<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Desafío de IA: Red A vs Red B</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <style>
        canvas { touch-action: none; cursor: crosshair; }
    </style>
</head>
<body class="bg-slate-900 text-white min-h-screen flex flex-col items-center p-4">

    <div class="w-full max-w-5xl">
        <!-- Encabezado -->
        <header class="text-center mb-8 mt-4">
            <h1 class="text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-red-500">
                Red B (Novato) vs. Red A (Experto)
            </h1>
            <p class="text-slate-400 mt-2">Dibuja una forma y ve quién predice mejor.</p>
        </header>

        <div class="flex flex-col md:flex-row gap-8 justify-center items-start">
            
            <!-- Área de Dibujo -->
            <div class="flex flex-col items-center bg-slate-800 p-6 rounded-2xl shadow-lg border border-slate-700">
                <h2 class="text-xl font-semibold mb-4 text-blue-200">Tu Dibujo</h2>
                <div class="relative bg-white rounded-lg overflow-hidden border-4 border-slate-600">
                    <canvas id="canvas" width="280" height="280" class="bg-black"></canvas>
                </div>
                
                <div class="flex gap-2 w-full mt-4">
                    <button onclick="predict()" id="btn-predict" class="flex-1 py-2 bg-green-600 hover:bg-green-500 rounded-lg font-bold transition disabled:bg-slate-700" disabled>
                        PREDECIR
                    </button>
                    <button onclick="clearCanvas()" class="px-4 py-2 bg-red-600 hover:bg-red-500 rounded-lg font-bold transition">
                        X
                    </button>
                </div>
                <p id="status" class="text-sm mt-2 text-yellow-500">Cargando modelos...</p>
            </div>

            <!-- Resultados -->
            <div class="flex-1 w-full space-y-6">
                
                <!-- Tarjeta Red B -->
                <div class="bg-slate-800 p-5 rounded-xl border-l-4 border-blue-500 shadow-lg">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-xl font-bold text-blue-400">Red B (Desde Cero)</h3>
                        <span id="pred-b-label" class="text-2xl font-black">?</span>
                    </div>
                    <!-- Barras de probabilidad -->
                    <div id="bars-b" class="space-y-1 text-xs"></div>
                </div>

                <!-- Tarjeta Red A -->
                <div class="bg-slate-800 p-5 rounded-xl border-l-4 border-red-500 shadow-lg">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-xl font-bold text-red-400">Red A (Transfer Learning)</h3>
                        <span id="pred-a-label" class="text-2xl font-black">?</span>
                    </div>
                    <!-- Barras de probabilidad -->
                    <div id="bars-a" class="space-y-1 text-xs"></div>
                </div>

            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURACIÓN ---
        // Estas son las clases de tu GitHub, en orden alfabético
        const CLASES = ['circulo', 'cuadrado', 'equis', 'estrella', 'rectangulo', 'rombo', 'semicirculo', 'triangulo'];

        let modelA, modelB;
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        let isDrawing = false;
        
        const statusEl = document.getElementById('status');
        const predictBtn = document.getElementById('btn-predict');

        // Configurar Canvas (Negro con linea Blanca, igual a MNIST)
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, 280, 280);
        ctx.strokeStyle = "white";
        ctx.lineWidth = 18; // Grosor similar al dataset
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        // Eventos de Dibujo
        const start = (e) => { isDrawing = true; ctx.beginPath(); draw(e); };
        const end = () => { isDrawing = false; ctx.beginPath(); };
        const draw = (e) => {
            if (!isDrawing) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            // Asegurarse de que las coordenadas del evento táctil o del mouse existan
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            if (clientX === undefined || clientY === undefined) return;
            
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            ctx.lineTo(x, y);
            ctx.stroke();
        };

        canvas.addEventListener('mousedown', start);
        canvas.addEventListener('mouseup', end);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('touchstart', start, { passive: false });
        canvas.addEventListener('touchend', end, { passive: false });
        canvas.addEventListener('touchmove', draw, { passive: false });

        // Cargar Modelos
        async function loadModels() {
            try {
                // --- ¡MODIFICACIÓN AQUÍ! ---
                // Añadimos '?v=1.1' para forzar al navegador a descargar
                // los archivos nuevos y no usar el caché.
                const cacheBuster = `?v=${new Date().getTime()}`;
                const modelB_path = `./model_B_web/model.json${cacheBuster}`;
                const modelA_path = `./model_A_web/model.json${cacheBuster}`;

                console.log(`Cargando modelo desde: ${modelB_path}`);
                console.log(`Cargando modelo desde: ${modelA_path}`);

                [modelB, modelA] = await Promise.all([
                    tf.loadLayersModel(modelB_path),
                    tf.loadLayersModel(modelA_path)
                ]);
                
                statusEl.innerText = "Modelos listos ✅";
                statusEl.className = "text-sm mt-2 text-green-400";
                predictBtn.disabled = false;
            } catch (e) {
                statusEl.innerText = "Error cargando modelos ❌";
                statusEl.className = "text-sm mt-2 text-red-500";
                console.error(e); // El error que me mostraste saldrá aquí
            }
        }
        loadModels();

        function clearCanvas() {
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, 280, 280);
            document.getElementById('pred-b-label').innerText = "?";
            document.getElementById('pred-a-label').innerText = "?";
            document.getElementById('bars-b').innerHTML = "";
            document.getElementById('bars-a').innerHTML = "";
        }

        async function predict() {
            if (!modelA || !modelB) return;

            // 1. Preprocesar imagen (280x280 -> 28x28 -> Normalizar)
            const tensor = tf.tidy(() => {
                let img = tf.browser.fromPixels(canvas, 1); // Leer en escala de grises
                img = tf.image.resizeBilinear(img, [28, 28]); // Redimensionar
                img = img.div(255.0); // Normalizar 0-1
                return img.expandDims(0); // Batch size [1, 28, 28, 1]
            });

            // 2. Predecir
            const resB = await modelB.predict(tensor).data();
            const resA = await modelA.predict(tensor).data();
            tensor.dispose();

            // 3. Mostrar Resultados
            showResults(resB, 'pred-b-label', 'bars-b', 'bg-blue-500');
            showResults(resA, 'pred-a-label', 'bars-a', 'bg-red-500');
        }

        function showResults(probs, labelId, containerId, colorClass) {
            const container = document.getElementById(containerId);
            container.innerHTML = "";
            
            // Encontrar la clase ganadora
            let maxIdx = 0;
            for(let i=1; i<probs.length; i++) if(probs[i] > probs[maxIdx]) maxIdx = i;
            document.getElementById(labelId).innerText = CLASES[maxIdx];

            // Dibujar barras
            for (let i = 0; i < CLASES.length; i++) {
                const p = (probs[i] * 100).toFixed(1);
                const width = Math.max(p, 1); // Mínimo 1% para que se vea algo
                
                // Resaltar la ganadora
                const isWinner = i === maxIdx;
                const opacity = isWinner ? 'opacity-100' : 'opacity-40';
                const fontWeight = isWinner ? 'font-bold text-white' : 'text-slate-400';

                const html = `
                    <div class="flex items-center gap-2 ${opacity}">
                        <span class="w-20 text-right ${fontWeight}">${CLASES[i]}</span>
                        <div class="flex-1 h-2 bg-slate-700 rounded-full overflow-hidden">
                            <div class="h-full ${colorClass}" style="width: ${width}%"></div>
                        </div>
                        <span class="w-10 text-xs">${p}%</span>
                    </div>
                `;
                container.innerHTML += html;
            }
        }
    </script>
</body>
</html>